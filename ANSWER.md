#  Task02

## 1
Вариант 
```
y1[n] = x[n - 1] + x[n] + x[n + 1]
```
 Будет проще реализовать, потому что здесь нет зависимости от уже посчитанных данных.  
 Поэтому этот вариант можно распараллелить для всех n
 
 ## 2
 Code divergance не будет, потому что 32 wavefront будет обрабатывать айтемы в воркгрупе построчно.  
 Поэтому когда wavefront будет переходить к следующей строчке `y` будет меняться везде, а `x` значения не имеет, тк умножается на `get_local_size(1) = 32`.  
 Поэтому ветка if будет одна и та же для каждого потока в wavefront.
 
 ## 3
 
 ### (a) `x + 32y`
 Да, будет непрерывное (coalesed) обращение. Потому, что для первой строчки ворк группы `y = 0`, а `x`  
 как раз увеличивается на 1 и после первых 32 айтемов (wavefront) как раз прочитается только одна кэш линия. 
 А всего тогда прочитается столько кэш линий, сколько строк в группе, то есть 32.
 
 ### (b) `y + 32x`
 Нет, это наоборот не будет coalesed. Тут для каждого айтема будет приходить своя кэш линия, потому что 
 `x` меняется на 1. Соответствено один wavefront будет запрашивать сразу 32 кэш линии.  
 Но всего кэш линий все равно останется 32, потому что они будут переиспользоваться каждой последующей строкой айтемов со сдвигом `y`.

### (c) `1 + x + 32y`
Да, будет coalesed, то есть запращиваемые данные будут все еще идти подряд. Только теперь у нас есть сдвиг на 1.  
Из-за этого суммарное число кэш линий будет 33. Потому что последний элемент вылезет на 1 за границy 32 кэш линии.
